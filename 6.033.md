Lecture 1
=========

Big complex systems can meet different problems:

- emergent properties (Ethernet cable: to validate the lack of collisions each
  packet is at least 64 bytes, because of the transfer speed)
- propagation of effects (If you touch one part of the system, other parts can
  be affected)
- increment to scaling issues (things working in small often don't work in large)

Sources of complexity:

- Too many goals, too many requirements
- Interacting features (combining features may lead to complexity)
- Performance goals

One of the most important things is choosing right abstraction. There is a
concept of layering abstraction: an abstraction that provides same power as an
abstraction right under it but gives a better interface to work with (assembly
-> C).

There is no algorithm for the right modularity. No clear way to cut system into
pieces, that's why we learn about it :).

This class is more about reading and writing design papers, no coding. Will have
both old and new papers (Unix and Map-Reduce). Most of them are about good
design and all of them are considered well written papers.


